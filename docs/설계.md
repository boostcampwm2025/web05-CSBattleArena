# ì‹¤ì‹œê°„ ëŒ€ì „ ê¸°ëŠ¥ ì™„ì„± êµ¬í˜„ ê³„íš (ê¸°ì¡´ ìŠ¤í™ ì¤€ìˆ˜)

## ğŸ“‹ êµ¬í˜„ ëª©í‘œ

**ê¸°ì¡´ ì‹¤ì‹œê°„ ëŒ€ì „ ê¸°ëŠ¥ì„ ì™„ì„±í•˜ê³  í”„ë¡ íŠ¸ì—”ë“œ-ë°±ì—”ë“œë¥¼ ì™„ì „íˆ ì—°ë™**

í˜„ì¬ ë§¤ì¹­, ë¼ìš´ë“œ ì‹œì‘, ì±„ì  ì‹œìŠ¤í…œì´ ë°±ì—”ë“œì— êµ¬í˜„ë˜ì–´ ìˆì§€ë§Œ, ê²Œì„ ì§„í–‰ ì´ë²¤íŠ¸ì™€ í”„ë¡ íŠ¸ì—”ë“œ ì—°ë™ì´ ë¯¸ì™„ì„± ìƒíƒœì…ë‹ˆë‹¤. **ê¸°ì¡´ `docs/ws.event.md` ìŠ¤í™ì„ ì¤€ìˆ˜**í•˜ì—¬ 5ë¼ìš´ë“œ ê²Œì„ì´ ì™„ì „íˆ ì‘ë™í•˜ë„ë¡ êµ¬í˜„í•©ë‹ˆë‹¤.

---

## ğŸ¯ êµ¬í˜„ ë²”ìœ„

### ì™„ë£Œëœ ë¶€ë¶„
- âœ… ë§¤ì¹­ í ì‹œìŠ¤í…œ (InMemoryMatchQueue)
- âœ… ê²Œì„ ì„¸ì…˜ ê´€ë¦¬ (MatchSessionManager)
- âœ… ë¼ìš´ë“œ ì‹œì‘ ë¡œì§ (QuizService í†µí•œ ë¬¸ì œ ìƒì„±)
- âœ… ì±„ì  ì‹œìŠ¤í…œ (ê°ê´€ì‹/ì£¼ê´€ì‹ AI ì±„ì )
- âœ… ì ìˆ˜ ê³„ì‚° (ë‚œì´ë„ + ìŠ¤í”¼ë“œ ë³´ë„ˆìŠ¤)
- âœ… ìµœì¢… ìŠ¹ì ê³„ì‚°
- âœ… ê¸°ë³¸ UI í™”ë©´ (Matching, Preparing, Playing, RoundResult)

### ë¯¸ì™„ì„± ë¶€ë¶„ (ë³¸ ì‘ì—…ì—ì„œ êµ¬í˜„)
- âŒ ê²Œì„ ì§„í–‰ ì´ë²¤íŠ¸ (round:ready, round:start, round:end, match:end)
- âŒ ì‹œê°„ ë™ê¸°í™” (round:tick)
- âŒ í”„ë¡ íŠ¸ì—”ë“œ ê²Œì„ ìƒíƒœ ê´€ë¦¬ (GameContext)
    - âŒ í™”ë©´ ì „í™˜ ë¡œì§ (Preparing â†’ Playing â†’ RoundResult)
- âŒ íƒ€ì´ë¨¸ êµ¬í˜„
- âŒ DB ì˜ì†ì„± (Match, Round, RoundAnswer ì €ì¥)
- âŒ ì—°ê²° í•´ì œ ì²˜ë¦¬
- âŒ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬

---

## ğŸ”„ ì´ë²¤íŠ¸ ì„¤ê³„ (ws.event.md ì¤€ìˆ˜)

### ë°±ì—”ë“œ â†’ í”„ë¡ íŠ¸ì—”ë“œ ì´ë²¤íŠ¸

| ì´ë²¤íŠ¸ëª… | ë°œì†¡ ì‹œì  | í˜ì´ë¡œë“œ | ì„¤ëª… |
|---------|---------|---------|------|
| `match:found` | ë§¤ì¹­ ì„±ê³µ | `{ opponent: { nickname, tier, expPoint } }` | ìƒëŒ€ ì •ë³´ (ì´ë¯¸ êµ¬í˜„ë¨) |
| `round:ready` | ë¼ìš´ë“œ ì‹œì‘ ì „ | `{ durationSec, roundIndex, totalRounds }` | ì¤€ë¹„ ì¹´ìš´íŠ¸ë‹¤ìš´ (3ì´ˆ) |
| `round:start` | ë¼ìš´ë“œ ì‹œì‘ | `{ durationSec, question }` | ë¬¸ì œ ì¶œì œ (30ì´ˆ) |
| `round:tick` | ë§¤ ì´ˆë§ˆë‹¤ | `{ remainedSec }` | ì‹œê°„ ë™ê¸°í™” |
| `round:end` | ì–‘ìª½ ì œì¶œ ì™„ë£Œ | `{ durationSec, results, solution }` | ì±„ì  ê²°ê³¼ (5ì´ˆ) |
| `match:end` | 5ë¼ìš´ë“œ ì™„ë£Œ | `{ isWin, finalScores }` | ìµœì¢… ê²Œì„ ê²°ê³¼ |
| `opponent:submitted` | ìƒëŒ€ ë‹µë³€ ì œì¶œ | `{}` | ìƒëŒ€ ì œì¶œ ì•Œë¦¼ (ì´ë¯¸ êµ¬í˜„ë¨) |
| `player:disconnected` | ìƒëŒ€ ì—°ê²° í•´ì œ | `{ reason }` | ì—°ê²° í•´ì œ ì•Œë¦¼ |

### í”„ë¡ íŠ¸ì—”ë“œ â†’ ë°±ì—”ë“œ ì´ë²¤íŠ¸

| ì´ë²¤íŠ¸ëª… | ë°œì†¡ ì‹œì  | í˜ì´ë¡œë“œ | ì„¤ëª… |
|---------|---------|---------|------|
| `submit:answer` | ë‹µë³€ ì œì¶œ | `{ answer: string }` | ë‹µë³€ ì œì¶œ (ì´ë¯¸ êµ¬í˜„ë¨) |

---

## ğŸ› ï¸ ë°±ì—”ë“œ ì‘ì—…

### 1. MatchSessionManager ìˆ˜ì •
**íŒŒì¼**: `packages/backend/src/match/match-session-manager.ts`

**ì¶”ê°€í•  í•„ë“œ (GameSession ì¸í„°í˜ì´ìŠ¤)**:
```typescript
roundTimers: Map<number, NodeJS.Timeout>;  // ë¼ìš´ë“œë³„ íƒ€ì´ë¨¸
tickIntervals: Map<number, NodeJS.Timeout>; // round:tick ì¸í„°ë²Œ
```

**ì¶”ê°€í•  ë©”ì„œë“œ**:
- `setRoundTimer(roomId, roundNumber, timer): void` - íƒ€ì„ì•„ì›ƒ íƒ€ì´ë¨¸ ì €ì¥
- `clearRoundTimer(roomId, roundNumber): void` - íƒ€ì´ë¨¸ ì œê±°
- `setTickInterval(roomId, roundNumber, interval): void` - í‹± ì¸í„°ë²Œ ì €ì¥
- `clearTickInterval(roomId, roundNumber): void` - ì¸í„°ë²Œ ì œê±°
- `getScores(roomId): { player1Score, player2Score }` - ì ìˆ˜ ì¡°íšŒ (ì´ë¯¸ êµ¬í˜„ë¨)

### 2. MatchGateway ìˆ˜ì •
**íŒŒì¼**: `packages/backend/src/match/match.gateway.ts`

#### ì‘ì—… 2-1: round:ready ì´ë²¤íŠ¸ ë°œì†¡ (ë§¤ì¹­ ì§í›„)
**ìœ„ì¹˜**: `handleMatchEnqueue` ë©”ì„œë“œ ë‚´, `startGame` í˜¸ì¶œ ì§í›„

```typescript
this.matchService.startGame(...);

// ì²« ë²ˆì§¸ ë¼ìš´ë“œ ì¤€ë¹„ ì´ë²¤íŠ¸ ë°œì†¡
setTimeout(() => {
  this.server.to(match.roomId).emit('round:ready', {
    durationSec: 3,
    roundIndex: 1,
    totalRounds: 5,
  });

  // 3ì´ˆ í›„ round:start ìë™ ë°œì†¡
  setTimeout(async () => {
    await this.startRound(match.roomId, 1);
  }, 3000);
}, 1000);
```

#### ì‘ì—… 2-2: startRound ë©”ì„œë“œ ì¶”ê°€
**ìƒˆ private ë©”ì„œë“œ**:

```typescript
private async startRound(roomId: string, roundIndex: number): Promise<void> {
  const roundData = await this.matchService.startRound(roomId);

  this.server.to(roomId).emit('round:start', {
    durationSec: 30,
    question: {
      category: ['General', 'Programming'], // TODO: ì‹¤ì œ ì¹´í…Œê³ ë¦¬
      difficulty: roundData.question.difficulty,
      type: roundData.question.type,
      content: this.formatQuestionContent(roundData.question),
    },
  });

  // 30ì´ˆ íƒ€ì„ì•„ì›ƒ ì„¤ì •
  const timer = setTimeout(async () => {
    await this.handleRoundTimeout(roomId, roundIndex);
  }, 30000);

  this.sessionManager.setRoundTimer(roomId, roundIndex, timer);

  // round:tick ì‹œì‘ (ë§¤ ì´ˆë§ˆë‹¤)
  let remainedSec = 30;
  const tickInterval = setInterval(() => {
    remainedSec--;
    this.server.to(roomId).emit('round:tick', { remainedSec });

    if (remainedSec <= 0) {
      clearInterval(tickInterval);
    }
  }, 1000);

  this.sessionManager.setTickInterval(roomId, roundIndex, tickInterval);
}

private formatQuestionContent(question: Question): any {
  if (question.type === 'multiple_choice') {
    return {
      question: question.question,
      option: Object.values(question.options),
    };
  } else {
    return { question: question.question };
  }
}

private async handleRoundTimeout(roomId: string, roundIndex: number): Promise<void> {
  const session = this.sessionManager.getGameSession(roomId);
  if (!session) return;

  const round = session.rounds.get(roundIndex);
  if (!round) return;

  // ë¯¸ì œì¶œ í”Œë ˆì´ì–´ì—ê²Œ ë¹ˆ ë‹µë³€ ìë™ ì œì¶œ
  if (round.submissions[session.player1Id] === null) {
    await this.matchService.submitAnswer(roomId, session.player1Id, '');
  }
  if (round.submissions[session.player2Id] === null) {
    await this.matchService.submitAnswer(roomId, session.player2Id, '');
  }
}
```

#### ì‘ì—… 2-3: submitAnswer í•¸ë“¤ëŸ¬ ìˆ˜ì •
**ìœ„ì¹˜**: `handleSubmitAnswer` ë©”ì„œë“œ

**ìˆ˜ì • í›„**:
```typescript
const result = await this.matchService.submitAnswer(roomId, userId, data.answer);

// opponent:submitted ë°œì†¡
const gameSession = this.sessionManager.getGameSession(roomId);
if (gameSession) {
  const opponentSocketId =
    userId === gameSession.player1Id
      ? gameSession.player2SocketId
      : gameSession.player1SocketId;

  this.server.to(opponentSocketId).emit('opponent:submitted', {});
}

// ì–‘ìª½ ì œì¶œ ì™„ë£Œ ì‹œ ì±„ì  ê²°ê³¼ ì²˜ë¦¬
if ('roundNumber' in result) {
  const roundResult = result;
  const session = this.sessionManager.getGameSession(roomId);
  const scores = this.sessionManager.getScores(roomId);

  // íƒ€ì´ë¨¸ ë° í‹± ì¸í„°ë²Œ ì·¨ì†Œ
  this.sessionManager.clearRoundTimer(roomId, roundResult.roundNumber);
  this.sessionManager.clearTickInterval(roomId, roundResult.roundNumber);

  // ì •ë‹µ ì¶”ì¶œ
  const round = session.rounds.get(roundResult.roundNumber);
  const question = round?.question;

  // ë‚´ ê²°ê³¼ì™€ ìƒëŒ€ ê²°ê³¼ êµ¬ë¶„
  const myGrade = roundResult.grades.find(g => g.playerId === userId);
  const opponentId = userId === session.player1Id ? session.player2Id : session.player1Id;
  const opponentGrade = roundResult.grades.find(g => g.playerId === opponentId);

  // round:end ë°œì†¡ (ê° í”Œë ˆì´ì–´ì—ê²Œ ê°œë³„ ì „ì†¡)
  this.server.to(session.player1SocketId).emit('round:end', {
    durationSec: 5,
    results: {
      my: {
        submitted: roundResult.grades.find(g => g.playerId === session.player1Id)?.answer || '',
        delta: roundResult.grades.find(g => g.playerId === session.player1Id)?.score || 0,
        total: scores.player1Score,
        correct: roundResult.grades.find(g => g.playerId === session.player1Id)?.isCorrect || false,
      },
      opponent: {
        submitted: roundResult.grades.find(g => g.playerId === session.player2Id)?.answer || '',
        delta: roundResult.grades.find(g => g.playerId === session.player2Id)?.score || 0,
        total: scores.player2Score,
        correct: roundResult.grades.find(g => g.playerId === session.player2Id)?.isCorrect || false,
      },
    },
    solution: {
      bestAnswer: this.getBestAnswer(question),
      explanation: myGrade?.feedback || '',
    },
  });

  this.server.to(session.player2SocketId).emit('round:end', {
    durationSec: 5,
    results: {
      my: {
        submitted: roundResult.grades.find(g => g.playerId === session.player2Id)?.answer || '',
        delta: roundResult.grades.find(g => g.playerId === session.player2Id)?.score || 0,
        total: scores.player2Score,
        correct: roundResult.grades.find(g => g.playerId === session.player2Id)?.isCorrect || false,
      },
      opponent: {
        submitted: roundResult.grades.find(g => g.playerId === session.player1Id)?.answer || '',
        delta: roundResult.grades.find(g => g.playerId === session.player1Id)?.score || 0,
        total: scores.player1Score,
        correct: roundResult.grades.find(g => g.playerId === session.player1Id)?.isCorrect || false,
      },
    },
    solution: {
      bestAnswer: this.getBestAnswer(question),
      explanation: opponentGrade?.feedback || '',
    },
  });

  // 5ì´ˆ í›„ ë‹¤ìŒ ë¼ìš´ë“œ ë˜ëŠ” ê²Œì„ ì¢…ë£Œ
  setTimeout(async () => {
    // ë§ˆì§€ë§‰ ë¼ìš´ë“œë©´ match:end ë°œì†¡ ë° DB ì €ì¥
    if ('finalResult' in roundResult && roundResult.finalResult) {
      await this.matchService.saveMatchResult(roomId, roundResult.finalResult);

      // match:end ë°œì†¡ (ê° í”Œë ˆì´ì–´ì—ê²Œ ê°œë³„)
      const isPlayer1Win = roundResult.finalResult.winnerId === session.player1Id;
      const isPlayer2Win = roundResult.finalResult.winnerId === session.player2Id;

      this.server.to(session.player1SocketId).emit('match:end', {
        isWin: isPlayer1Win,
        finalScores: {
          my: scores.player1Score,
          opponent: scores.player2Score,
        },
      });

      this.server.to(session.player2SocketId).emit('match:end', {
        isWin: isPlayer2Win,
        finalScores: {
          my: scores.player2Score,
          opponent: scores.player1Score,
        },
      });

      // ì„¸ì…˜ ì •ë¦¬
      this.sessionManager.deleteGameSession(roomId);
    } else {
      // ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
      const nextRoundIndex = roundResult.roundNumber + 1;
      this.server.to(roomId).emit('round:ready', {
        durationSec: 3,
        roundIndex: nextRoundIndex,
        totalRounds: 5,
      });

      setTimeout(async () => {
        await this.startRound(roomId, nextRoundIndex);
      }, 3000);
    }
  }, 5000);
}
```

**í—¬í¼ ë©”ì„œë“œ**:
```typescript
private getBestAnswer(question: Question): string {
  if (question.type === 'multiple_choice') {
    return question.answer;
  } else if (question.type === 'short_answer') {
    return question.answer;
  } else if (question.type === 'essay') {
    return question.sampleAnswer;
  }
  return '';
}
```

#### ì‘ì—… 2-4: ì—°ê²° í•´ì œ ì²˜ë¦¬ ìˆ˜ì •
**ìœ„ì¹˜**: `handleDisconnect` ë©”ì„œë“œ

```typescript
if (disconnectInfo.roomId && disconnectInfo.userId) {
  this.matchService.handlePlayerDisconnect(disconnectInfo.roomId, disconnectInfo.userId);

  // ìƒëŒ€ì—ê²Œ ì•Œë¦¼
  this.server.to(disconnectInfo.roomId).emit('player:disconnected', {
    reason: 'opponent_disconnected',
  });

  // ì„¸ì…˜ ì •ë¦¬
  this.sessionManager.deleteGameSession(disconnectInfo.roomId);
}
```

### 3. MatchService ìˆ˜ì •
**íŒŒì¼**: `packages/backend/src/match/match.service.ts`

#### ì‘ì—… 3-1: Repository ì˜ì¡´ì„± ì£¼ì…
**ìœ„ì¹˜**: constructor

```typescript
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { Match } from './entity/match.entity';
import { Round } from './entity/round.entity';
import { RoundAnswer } from './entity/round-answer.entity';

constructor(
  private readonly sessionManager: MatchSessionManager,
  private readonly aiService: QuizService,
  @InjectRepository(Match)
  private readonly matchRepository: Repository<Match>,
  @InjectRepository(Round)
  private readonly roundRepository: Repository<Round>,
  @InjectRepository(RoundAnswer)
  private readonly roundAnswerRepository: Repository<RoundAnswer>,
) {
  this.matchQueue = new InMemoryMatchQueue();
}
```

#### ì‘ì—… 3-2: handlePlayerDisconnect êµ¬í˜„
**ìœ„ì¹˜**: line 71-73 (í˜„ì¬ TODO)

```typescript
handlePlayerDisconnect(roomId: string, userId: string): void {
  const session = this.sessionManager.getGameSession(roomId);
  if (!session) return;

  const opponentId = userId === session.player1Id
    ? session.player2Id
    : session.player1Id;

  const scores = this.sessionManager.getScores(roomId);

  const finalResult: FinalResult = {
    winnerId: opponentId,
    scores: {
      [session.player1Id]: scores.player1Score,
      [session.player2Id]: scores.player2Score,
    },
    isDraw: false,
  };

  // DB ì €ì¥ (ë¹„ë™ê¸°ì§€ë§Œ fire-and-forget)
  this.saveMatchResult(roomId, finalResult).catch(err => {
    console.error('Failed to save disconnect result:', err);
  });
}
```

#### ì‘ì—… 3-3: saveMatchResult ë©”ì„œë“œ ì¶”ê°€

```typescript
async saveMatchResult(roomId: string, finalResult: FinalResult): Promise<void> {
  const session = this.sessionManager.getGameSession(roomId);
  if (!session) {
    throw new Error('Session not found');
  }

  // Guest ì‚¬ìš©ìëŠ” DB ì €ì¥ ìŠ¤í‚µ
  const isGuest1 = session.player1Id.startsWith('guest-');
  const isGuest2 = session.player2Id.startsWith('guest-');

  if (isGuest1 || isGuest2) {
    console.log('Guest users detected, skipping DB save');
    return;
  }

  await this.matchRepository.manager.transaction(async (manager) => {
    // 1. Match ìƒì„±
    const match = manager.create(Match, {
      player1Id: parseInt(session.player1Id),
      player2Id: parseInt(session.player2Id),
      winnerId: finalResult.winnerId ? parseInt(finalResult.winnerId) : null,
      matchType: 'multi',
    });
    const savedMatch = await manager.save(match);

    // 2. ê° ë¼ìš´ë“œ ì €ì¥
    for (const [roundNum, roundData] of session.rounds.entries()) {
      if (!roundData.question || !roundData.result) continue;

      const round = manager.create(Round, {
        matchId: savedMatch.id,
        questionId: roundData.question.id,
        roundNumber: roundNum,
      });
      const savedRound = await manager.save(round);

      // 3. ê° í”Œë ˆì´ì–´ ë‹µë³€ ì €ì¥
      for (const grade of roundData.result.grades) {
        const submission = roundData.submissions[grade.playerId];
        if (!submission) continue;

        const answerStatus = grade.isCorrect ? 'correct' : 'incorrect';

        const roundAnswer = manager.create(RoundAnswer, {
          userId: parseInt(grade.playerId),
          roundId: savedRound.id,
          userAnswer: submission.answer,
          score: grade.score,
          answerStatus,
          aiFeedback: grade.feedback,
        });
        await manager.save(roundAnswer);
      }
    }
  });
}
```

### 4. Quiz íƒ€ì… ìˆ˜ì •
**íŒŒì¼**: `packages/backend/src/quiz/quiz.types.ts`

**BaseQuestion ì¸í„°í˜ì´ìŠ¤ì— id í•„ë“œ ì¶”ê°€**:
```typescript
interface BaseQuestion {
  id?: number;  // ì¶”ê°€
  type: QuestionType;
  difficulty: Difficulty;
  question: string;
}
```

### 5. Match ëª¨ë“ˆ ìˆ˜ì •
**íŒŒì¼**: `packages/backend/src/match/match.module.ts`

**TypeOrmModuleì— ì—”í‹°í‹° ì¶”ê°€**:
```typescript
import { TypeOrmModule } from '@nestjs/typeorm';
import { Match, Round, RoundAnswer } from './entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([Match, Round, RoundAnswer]),
    // ... ê¸°ì¡´ imports
  ],
  // ...
})
```

---

## ğŸ’» í”„ë¡ íŠ¸ì—”ë“œ ì‘ì—…

### 1. íƒ€ì… ì •ì˜ ì¶”ê°€
**íŒŒì¼**: `packages/frontend/src/shared/type.ts`

```typescript
export type Difficulty = 'easy' | 'medium' | 'hard';
export type QuestionType = 'multiple_choice' | 'short_answer' | 'essay';

export interface MultipleChoiceOptions {
  A: string;
  B: string;
  C: string;
  D: string;
}

export interface Question {
  category: string[];
  difficulty: Difficulty;
  type: QuestionType;
  content: { question: string; option?: string[] };
}

export interface GameState {
  roomId: string;
  player1: UserData;
  player2: UserData;
  totalRounds: number;
  currentRound: number;
  player1Score: number;
  player2Score: number;
}

export interface RoundState {
  roundIndex: number;
  question: Question | null;
  durationSec: number;
  remainedSec: number;
  myAnswer: string;
  opponentSubmitted: boolean;
}

export type GamePhase = 'preparing' | 'playing' | 'result';

export interface RoundEndResult {
  my: {
    submitted: string;
    delta: number;
    total: number;
    correct: boolean;
  };
  opponent: {
    submitted: string;
    delta: number;
    total: number;
    correct: boolean;
  };
}
```

### 2. GameContext ìƒì„±
**íŒŒì¼**: `packages/frontend/src/feature/game/useGame.tsx` (ìƒˆ íŒŒì¼)

```typescript
import { createContext, useContext, useState } from 'react';
import { GameState, RoundState, GamePhase, RoundEndResult } from '@/shared/type';

interface GameAPI {
  gameState: GameState | null;
  roundState: RoundState | null;
  gamePhase: GamePhase;
  lastRoundResult: any | null;
  setGameState: (state: GameState | null) => void;
  setRoundState: (state: RoundState | null) => void;
  setGamePhase: (phase: GamePhase) => void;
  setLastRoundResult: (result: any) => void;
  updateRemainedSec: (sec: number) => void;
  setOpponentSubmitted: (submitted: boolean) => void;
  incrementRound: () => void;
  updateScores: (myScore: number, opponentScore: number) => void;
}

const GameCtx = createContext<GameAPI | null>(null);

export function GameProvider({ children }: { children: React.ReactNode }) {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [roundState, setRoundState] = useState<RoundState | null>(null);
  const [gamePhase, setGamePhase] = useState<GamePhase>('preparing');
  const [lastRoundResult, setLastRoundResult] = useState<any>(null);

  const updateRemainedSec = (sec: number) => {
    if (roundState) {
      setRoundState({ ...roundState, remainedSec: sec });
    }
  };

  const setOpponentSubmitted = (submitted: boolean) => {
    if (roundState) {
      setRoundState({ ...roundState, opponentSubmitted: submitted });
    }
  };

  const incrementRound = () => {
    if (gameState) {
      setGameState({ ...gameState, currentRound: gameState.currentRound + 1 });
    }
  };

  const updateScores = (myScore: number, opponentScore: number) => {
    if (gameState) {
      setGameState({
        ...gameState,
        player1Score: myScore,
        player2Score: opponentScore
      });
    }
  };

  return (
    <GameCtx.Provider
      value={{
        gameState,
        roundState,
        gamePhase,
        lastRoundResult,
        setGameState,
        setRoundState,
        setGamePhase,
        setLastRoundResult,
        updateRemainedSec,
        setOpponentSubmitted,
        incrementRound,
        updateScores,
      }}
    >
      {children}
    </GameCtx.Provider>
  );
}

export function useGame() {
  const ctx = useContext(GameCtx);
  if (!ctx) throw new Error('useGame must be used within GameProvider');
  return ctx;
}
```

### 3. useGameFlow í›… ìƒì„±
**íŒŒì¼**: `packages/frontend/src/feature/game/useGameFlow.tsx` (ìƒˆ íŒŒì¼)

```typescript
import { useEffect, useCallback, useRef } from 'react';
import { getSocket, getUserData } from '@/lib/socket';
import { useGame } from './useGame';
import { useMatch } from '@/feature/matching/useMatch';

export function useGameFlow() {
  const { setMatchState } = useMatch();
  const {
    setGameState,
    setRoundState,
    setGamePhase,
    setLastRoundResult,
    updateRemainedSec,
    setOpponentSubmitted,
    incrementRound,
    updateScores,
    gameState,
  } = useGame();

  const userData = getUserData();

  // round:ready ì´ë²¤íŠ¸
  const handleRoundReady = useCallback((data: any) => {
    setGamePhase('preparing');
    incrementRound();
  }, [setGamePhase, incrementRound]);

  // round:start ì´ë²¤íŠ¸
  const handleRoundStart = useCallback((data: any) => {
    setRoundState({
      roundIndex: gameState?.currentRound || 1,
      question: data.question,
      durationSec: data.durationSec,
      remainedSec: data.durationSec,
      myAnswer: '',
      opponentSubmitted: false,
    });

    setGamePhase('playing');
  }, [setRoundState, setGamePhase, gameState]);

  // round:tick ì´ë²¤íŠ¸
  const handleRoundTick = useCallback((data: any) => {
    updateRemainedSec(data.remainedSec);
  }, [updateRemainedSec]);

  // round:end ì´ë²¤íŠ¸
  const handleRoundEnd = useCallback((data: any) => {
    setLastRoundResult(data);
    updateScores(data.results.my.total, data.results.opponent.total);
    setGamePhase('result');
  }, [setLastRoundResult, updateScores, setGamePhase]);

  // match:end ì´ë²¤íŠ¸
  const handleMatchEnd = useCallback((data: any) => {
    console.log('Match ended:', data);
    // TODO: ìµœì¢… ê²°ê³¼ í™”ë©´ìœ¼ë¡œ ì´ë™
    setTimeout(() => {
      setMatchState('matching');
    }, 5000);
  }, [setMatchState]);

  // opponent:submitted ì´ë²¤íŠ¸
  const handleOpponentSubmitted = useCallback(() => {
    setOpponentSubmitted(true);
  }, [setOpponentSubmitted]);

  // player:disconnected ì´ë²¤íŠ¸
  const handlePlayerDisconnected = useCallback(() => {
    alert('ìƒëŒ€ê°€ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬í•©ë‹ˆë‹¤!');
    setMatchState('matching');
  }, [setMatchState]);

  useEffect(() => {
    const socket = getSocket();

    socket.on('round:ready', handleRoundReady);
    socket.on('round:start', handleRoundStart);
    socket.on('round:tick', handleRoundTick);
    socket.on('round:end', handleRoundEnd);
    socket.on('match:end', handleMatchEnd);
    socket.on('opponent:submitted', handleOpponentSubmitted);
    socket.on('player:disconnected', handlePlayerDisconnected);

    return () => {
      socket.off('round:ready', handleRoundReady);
      socket.off('round:start', handleRoundStart);
      socket.off('round:tick', handleRoundTick);
      socket.off('round:end', handleRoundEnd);
      socket.off('match:end', handleMatchEnd);
      socket.off('opponent:submitted', handleOpponentSubmitted);
      socket.off('player:disconnected', handlePlayerDisconnected);
    };
  }, [
    handleRoundReady,
    handleRoundStart,
    handleRoundTick,
    handleRoundEnd,
    handleMatchEnd,
    handleOpponentSubmitted,
    handlePlayerDisconnected,
  ]);
}
```

### 4. í™”ë©´ ì»´í¬ë„ŒíŠ¸ ìˆ˜ì •

#### TopBar.tsx ìˆ˜ì •
- `roundState.remainedSec` í‘œì‹œ
- í˜„ì¬ ë¼ìš´ë“œ/ì´ ë¼ìš´ë“œ í‘œì‹œ
- ì ìˆ˜ í‘œì‹œ

#### Preparing.tsx ìˆ˜ì •
- 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ
- "GET READY!" ë©”ì‹œì§€

#### Playing.tsx ìˆ˜ì •
- `roundState.question` ë°ì´í„°ë¡œ ë¬¸ì œ í‘œì‹œ
- ê°ê´€ì‹: `question.content.option` ë°°ì—´ë¡œ ì„ íƒì§€ í‘œì‹œ
- ì£¼ê´€ì‹/ì„œìˆ í˜•: í…ìŠ¤íŠ¸ ì…ë ¥
- `roundState.remainedSec`ë¡œ íƒ€ì´ë¨¸ í‘œì‹œ
- `submit:answer` ì´ë²¤íŠ¸ ë°œì†¡

#### RoundResult.tsx ìˆ˜ì •
- `lastRoundResult.results.my`, `lastRoundResult.results.opponent` í‘œì‹œ
- `lastRoundResult.solution.bestAnswer` ì •ë‹µ í‘œì‹œ
- `lastRoundResult.solution.explanation` í”¼ë“œë°± í‘œì‹œ
- 5ì´ˆ ëŒ€ê¸° í›„ ìë™ ë‹¤ìŒ ë¼ìš´ë“œ

#### InGame.tsx ìˆ˜ì •

```typescript
import { useGame } from '@/feature/game/useGame';
import { useGameFlow } from '@/feature/game/useGameFlow';

export default function InGame() {
  useGameFlow(); // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë‹
  const { gamePhase } = useGame();

  return (
    <div className="relative z-10 flex h-full w-full flex-col">
      <TopBar />
      {gamePhase === 'preparing' && <Preparing />}
      {gamePhase === 'playing' && <Playing />}
      {gamePhase === 'result' && <RoundResult />}
    </div>
  );
}
```

### 5. Provider ì¶”ê°€
**íŒŒì¼**: `packages/frontend/src/app/App.tsx`

```typescript
import { GameProvider } from '@/feature/game/useGame';

<MatchProvider>
  <GameProvider>
    {/* ê¸°ì¡´ ë¼ìš°íŒ… */}
  </GameProvider>
</MatchProvider>
```

---

## ğŸ“Š ì´ë²¤íŠ¸ ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨

```
[ë§¤ì¹­ ì™„ë£Œ]
Frontend â†’ match:enqueue
Backend  â†’ match:found

[ë¼ìš´ë“œ 1 ì‹œì‘]
Backend  â†’ round:ready { durationSec: 3, roundIndex: 1 }
(3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´)
Backend  â†’ round:start { durationSec: 30, question }
Backend  â†’ round:tick { remainedSec: 30 } (ë§¤ ì´ˆ)

[ë‹µë³€ ì œì¶œ]
Frontend â†’ submit:answer { answer }
Backend  â†’ opponent:submitted (ìƒëŒ€ì—ê²Œ)
Frontend â†’ submit:answer (ì–‘ìª½ ì œì¶œ)
Backend  â†’ round:end { results, solution }

[ë¼ìš´ë“œ 2-5 ë°˜ë³µ]
(5ì´ˆ ê²°ê³¼ í™”ë©´ í›„)
Backend  â†’ round:ready { roundIndex: 2 }
...

[ê²Œì„ ì¢…ë£Œ]
Backend â†’ match:end { isWin, finalScores }
Backend â†’ DB ì €ì¥
Backend â†’ ì„¸ì…˜ ì •ë¦¬
```

---

## ğŸ”§ êµ¬í˜„ ìˆœì„œ

### Phase 1: ë°±ì—”ë“œ ê¸°ë³¸ ì´ë²¤íŠ¸ (3-4ì‹œê°„)
1. MatchSessionManagerì— íƒ€ì´ë¨¸ ê´€ë¦¬ ì¶”ê°€
2. MatchGatewayì— round:ready, round:start, round:tick ë°œì†¡
3. MatchGatewayì˜ submitAnswerì— round:end, match:end ë°œì†¡
4. startRound ë©”ì„œë“œ êµ¬í˜„

**ê²€ì¦**: Postman/Socket.IO í´ë¼ì´ì–¸íŠ¸ë¡œ ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸

### Phase 2: í”„ë¡ íŠ¸ì—”ë“œ ìƒíƒœ ê´€ë¦¬ (2-3ì‹œê°„)
1. type.tsì— íƒ€ì… ì •ì˜
2. useGame.tsx êµ¬í˜„
3. useGameFlow.tsx êµ¬í˜„
4. GameProvider ì¶”ê°€

**ê²€ì¦**: React DevToolsë¡œ ìƒíƒœ í™•ì¸

### Phase 3: í”„ë¡ íŠ¸ì—”ë“œ í™”ë©´ ì—°ë™ (3-4ì‹œê°„)
1. TopBar, Preparing, Playing, RoundResult ìˆ˜ì •
2. InGame ìˆ˜ì •

**ê²€ì¦**: 2ê°œ ë¸Œë¼ìš°ì €ë¡œ ì‹¤ì œ ëŒ€ì „ í…ŒìŠ¤íŠ¸

### Phase 4: íƒ€ì„ì•„ì›ƒ ë° ì˜ˆì™¸ ì²˜ë¦¬ (1-2ì‹œê°„)
1. íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ (ì´ë¯¸ Phase 1 í¬í•¨)
2. ì—°ê²° í•´ì œ ì²˜ë¦¬

**ê²€ì¦**: ì˜ˆì™¸ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

### Phase 5: DB ì˜ì†ì„± (1-2ì‹œê°„)
1. Repository ì£¼ì…
2. saveMatchResult êµ¬í˜„

**ê²€ì¦**: DB í™•ì¸

---

## ğŸ“ ì¤‘ìš” íŒŒì¼ ê²½ë¡œ

### ë°±ì—”ë“œ
- `packages/backend/src/match/match.gateway.ts`
- `packages/backend/src/match/match.service.ts`
- `packages/backend/src/match/match-session-manager.ts`
- `packages/backend/src/match/match.module.ts`
- `packages/backend/src/quiz/quiz.types.ts`

### í”„ë¡ íŠ¸ì—”ë“œ
- `packages/frontend/src/shared/type.ts`
- `packages/frontend/src/feature/game/useGame.tsx` (ì‹ ê·œ)
- `packages/frontend/src/feature/game/useGameFlow.tsx` (ì‹ ê·œ)
- `packages/frontend/src/pages/match/components/InGame.tsx`
- `packages/frontend/src/pages/match/components/in-game/*`

---

## â±ï¸ ì˜ˆìƒ ì†Œìš” ì‹œê°„

**ì´ ì˜ˆìƒ ì‹œê°„**: 12-18ì‹œê°„ (1.5-2.5ì¼)

---

## âš ï¸ ì£¼ìš” ì£¼ì˜ì‚¬í•­

1. **ê¸°ì¡´ ìŠ¤í™ ì¤€ìˆ˜**: `docs/ws.event.md`ì˜ í˜ì´ë¡œë“œ êµ¬ì¡° ì •í™•íˆ ë”°ë¥´ê¸°
2. **round:tick**: ë§¤ ì´ˆë§ˆë‹¤ ë°œì†¡í•˜ì—¬ ì‹œê°„ ë™ê¸°í™”
3. **ê°œë³„ ì´ë²¤íŠ¸**: `round:end`, `match:end`ëŠ” ê° í”Œë ˆì´ì–´ë³„ë¡œ `my`/`opponent` êµ¬ë¶„í•˜ì—¬ ë°œì†¡
4. **Guest ì‚¬ìš©ì**: DB ì €ì¥ ìŠ¤í‚µ ì²˜ë¦¬
5. **íƒ€ì´ë¨¸ ì •ë¦¬**: ë¼ìš´ë“œ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ì™€ ì¸í„°ë²Œ ëª¨ë‘ clearTimeout/clearInterval
